

#### gplots function was used to plot heatmap with color key#############
library(gplots)

# nils: Removed the following two lines. This is way to dangerous. This pipeline was throwing errors
# that did not get picked up.
#sink(stderr(), type="message")
#sink(stdout(), type="message")

require(cluster, quietly=TRUE)
require(Cairo, quietly=TRUE)
options(warn=-1)

main=function(...) {
	args <- list(...)
	for(i in 1:length(args)) {
		flag <- substring(args[[i]], 0, 2)
		value <- substring(args[[i]], 3, nchar(args[[i]]))
		if (flag == '-c') {
			cophenetic = value
		}
		else if(flag=='-m') {
			measure=value
		}
		else if(flag=='-u'){
			inputexp=value
		}
		else if(flag=='-v'){
			output=value
		}
		else if(flag=='-w'){
			clumembership=value
		}		
		else if(flag=='-p'){
			inputallexp=value
		}
	}
	
	# nils: This prevents informational message generated by packages during loading that would go
	# to stderr and cause the module to fail (due to output to stderr).
	suppressPackageStartupMessages(loader())

	#print(inputallexp)
	
	# nils: The full expression file generated by the preprocessor (e.g. mRNA_Preprocess_Median) is
	# read and the dots "." in the sample names are replaced with hyphens "-". However, this matrix
	# does not get used to do the computation of the silhouette width. Also, the output of the
	# preprocessor used for the NCI workspaces doesn't contain dots to begin with. This might be
	# the case for previous workspaces as well.
	exp <- read.data(inputallexp)
	colnames(exp) <- gsub("\\.","-",colnames(exp))
	
	# Remove up to 2 leading non-numeric columns.
	if (all(is.na(as.numeric(exp[,1])))) {
		exp=exp[, -1,drop=F]
		if (all(is.na(as.numeric(exp[,1])))) {
			exp=exp[, -1,drop=F]
		}
	}
	
	selectBestcluster(exp,measure,inputexp,output,clumembership, cophenetic)
}


## for the expression file ##


# nils:
# allexpression - Matrix of normalized expression levels directly from the preprocessor with fixed samples names ("." replaced with "-") 
# measure - Correlation measure. "Pearson" seems to be the default set by Firehose.
# inputexp - Filename for the normalized expression matrix with the selected genes.
# output - This is the individual set id, e.g. "LUSC".
# clumembership - Table of cluster memberships for different k. First column contains sample names with hyphens.
# cophenetic - The file where the cophenetic coeffecients can be loaded from.
selectBestcluster <- function(allexpression,measure,inputexp,output,clumembership, cophenetic) {

# nils: if running from local directory:
# inputexp <- "cnmf.normalized.gct"
# clumembership <- "cnmf.membership.txt"
# measure <- "Pearson"

	#calculate dissimilarity matrix
	
	# nils: Reading GCT file with normalized expression profiles of selected genes.
	dism <-read.delim(file=inputexp,sep="\t",skip=2,as.is=T,header=T,check.names = F)
	#dism <-read.delim(file=inputexp,sep="\t",as.is=T,header=T,check.names = F)
	
	# nils -- added 1 line: Replace "." in column names (= TCGA bar codes = sample names) with "-" to match
	# samples names in cluster membership table (see below).
	colnames( dism ) <- gsub( "\\.", "-", colnames( dism ) );	
	
	# nils: Set gene names as row names.
	row.names(dism) <- dism[,1]
	
	# nils: Remove the first two columns (gene names and description).
	dism <- as.matrix(dism[,-c(1:2)])
	
	#dism <- read.data(inputexp)
	
	# nils: Compute correlation matrix.
	if (measure == "Pearson") {
		fdist <- cor(dism,method="pearson")
		cormatrix <- fdist
		fdist <- 1-fdist
	  
	}else if (measure == "Euclidean") {
		fdist <- dist(t(dism),method="euclidean")
		fdist <- as.matrix(fdist)
		cormatrix <- fdist
	}
  
	write.table(cormatrix,file=paste(output,".samplebysamples.txt",sep=""),sep="\t",quote=F)
	# nils: What happens in the "else" case??? Will break, since there is no fdist or cormatrix.
	# Maybe one of the above methods could be used as fallback if more stable (but less transparent)
	# code is desired.
		
	#calculate silhouette value for selecting Best cluster

		# nils: Read cluster membership table.
		clumem <-read.table(clumembership,sep="\t",header=T,check.names = F)
		#adunford: Nope, rownames already assigned indeed.  This causes an error
		#rownames(clumem) <- clumem[,1]
		#adunford: I think this was meant to work with the above row when it worked
		#clumem <- clumem[,-1]
		
		# nils: Re-order rows and columns in correlation matrix to match order of samples in cluster
		# membership table. This is needed for use in call to "shilouette" below.
		# WARNING: This function call failed (silently due to sinking of error messages) because
		# the sample names in the expression data file did not match the samples names in the 
		# cluster membership table (the "." vs "-" problem). This was a "subscript out of bounds" error.
		# This has been addressed with the added code above.
		
		
		# nils: nn = nxn = dimensions of the cluster membership table (rows = samples, columns = options for k)
		nn <- dim(clumem)
		
		#snms <- NULL
		sil <- NULL
		sil_all <- NULL
		allclu <- NULL
		
		# nils: Computation of (average) silhouette widths for all options of k.
		#adunford: removing na-containing fields because they seem to cause errors despite the fact it works in Firehose....
		naidx = !is.na(fdist)[,1]
		fdist = fdist[naidx,naidx]
		clumem = clumem[naidx,];
		for (i in 1:nn[2]) {
			
			# nils: Computation of silhouette width for the ith k.
			print(nrow(clumem))
			print(nrow(fdist))
			clu_si <- silhouette((clumem[,i]),fdist);
			#clu_si <- silhouette(clumem[,i],fdist2)

			# nils: Not sure if this is really required.
			rownames(clu_si) <- rownames(clumem)
			
			# nils: Store average silhouette width for ith k.
			sil <- cbind(sil,mean(clu_si[,"sil_width"]))
			
			# nils: Store silhouette width individual samples for this k.
			sil_all <- cbind(sil_all,clu_si[,"sil_width"])
		}
		
		# nils: Determine k with highest silhouette width and return index.
		# WARNING: This code will never return the first index. Unclear why this is done. It forces
		# the script to always return a k > min_k (min_k is the minimum k tested).
		# Also, this could be done more elegantly with "which.max".		
		
		# nils -- removed 2 lines: see comment above
		# t <- which(sil == max(sil[-1]))		
		# kclus <- as.numeric(t)		
		
		# Select the best cluster name and index on the basis of the cophenetic coefficient values provided
		
    values <- read.delim(cophenetic, sep = "\t")
		
	  peak <- NULL
		slope <- sapply(1:(dim(values)[1]-1),function(i){
		tslope <- (values[i+1,1]-values[i,1])
		return(tslope)
	})
    
	  difslope <- slope[2:6]
	  tk <- which(difslope == min(difslope))+1
	  peak <- cbind(peak,tk)
	  #nn <- length(difslope)
	  #secondv <- sort(difslope,partial=nn-1)[nn-1]
	  #tdifslope <- difslope[-(tk-1)]
	  #tk <- which(difslope == min(tdifslope))+1
    #tk <- which(difslope == secondv)+1
	  #peak <- cbind(peak,tk)
  
		t <- which(slope >= 0)
		if(length(t) == 0) {
		  t1 <- which.max(sil[peak[1,]])
		  kclus <- peak[1,t1]
		}else if (length(t) == 1){
			tk <- t[1] +1
			peak <- cbind(peak,tk)
			t1 <- which.max(sil[peak[1,]])
			kclus <- peak[1,t1]  
		}else {
		  #peak <- sapply(1:(length(slope)-1), function(j){ if(slope[j] >0 && slope[j+1] <0) return(j) })
      for(j in 1:(length(slope)-1)) {
        #print(j)
        if(slope[j] >=0 && slope[j+1] <=0) {
          temp <- j+1
          #print(j)
          peak <- cbind(peak,temp)
        }     
      }
      #if(length(peak) <= 1) {
      #  if(!is.null(peak)) {
      #    kclus <- peak[1]+1
      #  }else {
      #    kclus <- which.max(values[,1])
      #  }
        
      #}else{
        #peak <- peak+1
        t1 <- which.max(sil[peak[1,]])
        kclus <- peak[1,t1]
      #}
      
		}
		# nils -- added 1 line:
		#kclus <- which.max( sil );	
			
		
		# nils: If best cluster index is greater 5 (i.e. k > 6 with min_k = 2), then set the best
		# cluster index to 1 (i.e. k = 2 with min_k = 2)
		# TODO: It is unclear why this is done. This seems to artificially limit the maximum number
		# of clusters allowed.
        
        # nils -- removed 1 line: see comment above
        # if(kclus > 5 ) {kclus <- 1}

		
		# nils: Create a vector of labels of the form "K=2", "K=3", ...
		# TODO: This should take into account what the minimum k value is. However, this module is
		# not explicitly told what this is. None of the input files seem to contain this information
		# either.
		#tname <- paste("K=",c(seq(2,(nn[2]+1))),sep="")
		tname <- paste("K=", row.names(values), sep = "")
		maxK <- length(sil)+1
		k.vector <- vector(mode = "numeric", length = length(sil))
		k.vector <- c(2:maxK)
	
		# nils: Open device and create canvas for silhouette figure.
		CairoPNG(paste(output,".silfig.png",sep=""),width=1200,height=1200)

		# nils: Split canvas into two columns.
		#par(mai = c(0.9, 0.9, 0.2, 0.2), mfrow = c(1, 2))
		layout(matrix(c(1,3,2,3), 2, 2, byrow = TRUE))

		# nils: Plot "boxes" for each silhouette values. Because each value is only a scalar there 
		# will only be lines. By replacing sil with sil_all we would get boxes.
		#boxplot(sil,names=tname,main="Average silhouette value in each cluster",ylab="Silhouette value")

		# nils: Mark the k that has been chosen as the best k with a red dot (the report is talking
		# about a "blue" marker - not sure why).
		#points(kclus,sil[kclus],pch=18,col="red",bg="red",cex=2.5)
		
		plot(k.vector,sil, main ="Average silhouette value in each cluster",xlab = "k", ylab="silhouette width", type = "n")
  		lines(k.vector,sil, type = "l", col = "black")
  		points(k.vector,sil, pch=22, type = "p", cex = 1.25, bg = "black", col = "black")
  		points((kclus+1),sil[kclus],pch=18,col="red",bg="red",cex=2.5)
		
		plot(k.vector,values[,1], main ="Cophenetic Coefficient in each cluster",xlab = "k", ylab="Cophenetic Coefficient", type = "n")
  		lines(k.vector,values[,1], type = "l", col = "black")
  		points(k.vector,values[,1], pch=22, type = "p", cex = 1.25, bg = "black", col = "black")
  		points((kclus+1),values[(kclus),1],pch=18,col="red",bg="red",cex=2.5)
		
		
		#dev.off()
		#line1 <- as.numeric(t)+1
		#line1 <- paste("#The best cluster is K=",line1,sep="")
		#print("finished")
		
		# nils: Save the sample-to-cluster assignment for the best k.
	clumem <- clumem[order(clumem[,kclus]),]
	fdist <- fdist[rownames(clumem),rownames(clumem)]  		
  clubest <- clumem[,kclus]

		# nils: Save the silhouette values for the best cluster assingment.
		silbest <- sil_all[,kclus]
		
		# nils: Create a table of the best silhouette values and best cluster assignments.
		allbest <- cbind(SampleName = rownames(clumem), cluster = clubest,silhouetteValue = silbest)
		
		# nils: Compute the silhouette values (again???) for the best cluster assignment.
		# This might be done to get the whole silhouette object for plotting further down.
		clu_si <- silhouette(clubest,fdist)
		
		#CairoPNG(paste(output,".bestsilhouettefig.png",sep=""),width=600,height=1200)

		# nils: Get cluster color for each sample.
		groupCol <- getColor(allbest[,2])
		
		# nils: Plot silhouettes for best clustering.
		plot(clu_si,col=groupCol,main="Silhouette value for each sample in best cluster")
	  #plot(clu_si,col=c("red","blue","purple"),main="Silhouette value for each sample in best cluster")
		
		# nils: Close device (i.e. write the file).
		dev.off()

# ======= nils: analyzed file to here ==============================================================
		
		#find markers
		allbest <- allbest[order(allbest[,2]),]

		cormatrix <- cormatrix[as.character(allbest[,1]),as.character(allbest[,1])]
		CairoPNG(paste(output,".cormatrix.png",sep=""),width=800,height=800)
		
		groupCol <- getColor(allbest[,2])
		blueWhiteRedGradient <-colorRampPalette( c("blue", "white", "red" ) )

		#heatmap(cormatrix,col=rainbow(100),Rowv = NA,Colv = "Rowv",scale="none",labRow="",labCol="",xlab="Samples",ylab="Samples",ColSideColors=groupCol)
		heatmap.2(cormatrix,col=blueWhiteRedGradient(100),Rowv = FALSE,Colv = "Rowv",scale="none",labRow="",labCol="",xlab="Samples",ylab="Samples",ColSideColors=groupCol,key = TRUE,dendrogram="none",density.info="none",trace="none",breaks=seq(-1,1,0.02),symbreaks=TRUE,symkey=TRUE)		
		dev.off()

		
		line1 <- t(colnames(allbest))
		write.table(line1,file=paste(output,".bestclus.txt",sep=""),sep="\t",quote=F,row.names=F,col.names=F)
		write.table(allbest,file=paste(output,".bestclus.txt",sep=""),sep="\t",quote=F,row.names=F,col.names=T,append=T)

		tpositive <- which(as.numeric(allbest[,3]) >= 0)
		allbest_o <- allbest
		allbest <- allbest[tpositive,]
		vectors <- unique(allbest[,2])
		allttest <- NULL
		Sigttest <- NULL
		for (i in 1:length(vectors)) {
			#print(i)
			tid <- which(allbest[,2] %in% vectors[i])
			if(length(tid) > 5) {
				tumor_id <- which(colnames(allexpression) %in% allbest[tid,1])
				normal_id <- which(colnames(allexpression) %in% allbest[-tid,1])
				ttest <- getttest(allexpression,tumor_id,normal_id)
				ttest <- t(ttest)
				tna <- which(ttest[,3] %in% "NA")
				if (length(tna) > 0 ) {
				 ttest <- ttest[-tna,]
				}
				
				ttest <- cbind(ttest,p.adjust(as.numeric(ttest[,2]),"BH"))
				ts <- which(as.numeric(ttest[,2]) <= 0.05 & as.numeric(ttest[,4]) <= 0.25 )
				if (length(ts) >0 ){  
				  ttest <- ttest[ts,]
				}      
        
        if(dim(ttest)[1] > 300 ) {
				
					#ttest <- ttest[order(as.numeric(ttest[,3]),decreasing=T),]
					
					pos <- which(as.numeric(ttest[,3]) >= 0)
					
					if(length(pos) > 0 & length(pos) < dim(ttest)[1]) {
						mpos <- matrix(ttest[pos,],ncol=4)
						mpos <- mpos[order(as.numeric(mpos[,4])),]
						mneg <- matrix(ttest[-pos,],ncol=4)
						mneg <- mneg[order(as.numeric(mneg[,4])),]
						
						neg <- dim(mneg)[1]
						if (length(pos) >= 150) {mpos <- mpos[1:150,]}
						if(neg >= 150) {mneg <- mneg[1:150,]}
						sttest <- rbind(mpos,mneg)
						sttest <- cbind(sttest,rep(vectors[i],dim(sttest)[1]))
						ttest <- cbind(ttest,rep(vectors[i],dim(ttest)[1]))				
						allttest <- rbind(allttest,ttest)
						Sigttest <- rbind(Sigttest,sttest)
							
					} else {
						ttest <- cbind(ttest,rep(vectors[i],dim(ttest)[1]))				
						allttest <- rbind(allttest,ttest)
						Sigttest <- allttest
					}
										
							
				}else {
					ttest <-  matrix(ttest,ncol=4)	
		      ttest <- ttest[order(as.numeric(ttest[,3]),decreasing=T),]
          ttest <-  matrix(ttest,ncol=4)
					ttest <- cbind(ttest,rep(vectors[i],dim(ttest)[1]))
					allttest <- rbind(allttest,ttest)
					Sigttest <- allttest

				}

			}
		}
	
 if(!is.null(allttest)) {
   
   colnames(allttest) <- c("Hybridization REF","p","difference","q","subclass")
   colnames(Sigttest) <- c("Hybridization REF","p","difference","q","subclass")
   vv <- c("Composite Element REF","p","difference","q","subclass")
   allttest <- rbind(vv,allttest)
   write.table(allttest,file=paste(output,".subclassmarkers.txt",sep=""),sep="\t",quote=F,row.names=F)
   write.table(Sigttest,file=paste(output,".selectmarker.txt",sep=""),sep="\t",quote=F,row.names=F)
   
   mapexp <- allexpression[Sigttest[,1],allbest_o[,1]]
   temp <- apply(mapexp,2,as.numeric)
   row.names(temp) <- row.names(mapexp)
   temp <- scale(t(temp), center = TRUE, scale = FALSE)
   mapexp <- t(temp)
   
   
   qnum <- quantile(mapexp,c(0.1,0.9),na.rm=T)
   mapexp[mapexp >= qnum[2]] <- qnum[2]
   mapexp[mapexp <= qnum[1]] <- qnum[1]
   
   
   ##### Plot heatmap figure #############
   #verticalBorder <- 150
   #horizontalBorder <- 150
   
   #CairoPNG(paste(output,".geneheatmap.png",sep=""),width=dim( mapexp )[2] + horizontalBorder, height=dim( mapexp )[1] + verticalBorder )
   
   
   CairoPNG(paste(output,".geneheatmap.png",sep=""),width=1800, height=1600)
   #par(mai = c(0.9, 0.9, 0.2, 0.2), mfrow = c(2, 1))
   #Cairo(1800, 1200, file=paste(output,".geneheatmap.jpg",sep=""), type="jpg", bg="white", quality=100 )
   
   ###########The following two command is used to plot heatmap with color key by heatmap.2 function
   
   rowside <- getColor(as.character(Sigttest[,5]))
   #maxValue <- max(abs(mapexp) , na.rm = TRUE)
   #heatmap.2(mapexp,col=blueWhiteRedGradient(100),Rowv = FALSE,Colv = "Rowv",scale="none",labRow="",labCol="",xlab="Samples",ylab="Genes",ColSideColors=groupCol,RowSideColors=rowside,key = TRUE,dendrogram="none",density.info="none",trace="none",na.rm = TRUE, breaks = seq(-maxValue, maxValue, (2 * maxValue) / 100))
   heatmap.2(mapexp,col=blueWhiteRedGradient(100),Rowv = FALSE,Colv = "Rowv",scale="none",labRow="",labCol="",xlab="Samples",ylab="Genes",ColSideColors=groupCol,RowSideColors=rowside,key = TRUE,dendrogram="none",density.info="none",trace="none",na.rm = TRUE)
   
   
   #heatmap(dism,col=rainbow(100),Rowv = NA,Colv = "Rowv",scale="none",labRow="",labCol="",xlab="Samples",ylab="Genes",ColSideColors=groupCol)
   #dev.off()
   
   ############The following two command is used to plot heatmap without color key by heatmap function
   #rowside <- getColor(sort(Sigttest[,5],decreasing=T))
   #heatmap(mapexp,col=rainbow(100),Rowv = NA,Colv = "Rowv",scale="row",labRow="",labCol="",xlab="Samples",ylab="Genes",ColSideColors=groupCol,RowSideColors=rowside)
   
   dev.off()
   
   
 }else {
   vv <- c("Composite Element REF","p","difference","q","subclass")
   tvv <- rbind(vv,vv)
   write.table(tvv,file=paste(output,".subclassmarkers.txt",sep=""),sep="\t",quote=F,row.names=F,col.names=F)
   write.table(t(vv),file=paste(output,".selectmarker.txt",sep=""),sep="\t",quote=F,row.names=F,col.names=F)
   
   #t <- apply(allexpression,1,function(x) length(which(as.numeric(x[-1]) == 0)))
   #tt <- which(t >= round(dim(allexpression)[2]*0.7))
   #if(length(tt) > 0 ) {
     #exp_raw <- exp_raw[-tt,]
    # allexpression <- allexpression[-tt,]
   #}  
   
   mapexp <- allexpression[,allbest_o[,1]]
   temp <- apply(mapexp,2,as.numeric)
   row.names(temp) <- row.names(mapexp)
   temp <- scale(t(temp), center = TRUE, scale = FALSE)
   mapexp <- t(temp)
   
   
   qnum <- quantile(mapexp,c(0.1,0.9),na.rm=T)
   mapexp[mapexp >= qnum[2]] <- qnum[2]
   mapexp[mapexp <= qnum[1]] <- qnum[1]
   
   
   
   CairoPNG(paste(output,".geneheatmap.png",sep=""),width=1800, height=1600)
  
   heatmap.2(mapexp,col=blueWhiteRedGradient(100),Rowv = FALSE,Colv = "Rowv",scale="none",labRow="",labCol="",xlab="Samples",ylab="Genes",ColSideColors=groupCol,key = TRUE,dendrogram="none",density.info="none",trace="none",na.rm = TRUE)
   
   dev.off()
   
   
 }


	qnum <- quantile(dism,c(0.1,0.9),na.rm=T)
	dism[dism >= qnum[2]] <- qnum[2]
	dism[dism <= qnum[1]] <- qnum[1]
	dism <- dism[,allbest_o[,1]]
	
	
########### plot heatmap figure with 1500 genes and all samples #######################
	CairoPNG(paste(output,".geneheatmaptopgenes.png",sep=""),width=2500, height=2000)

		#heatmap.2(dism,col=blueWhiteRedGradient(100),Rowv = TRUE,Colv = TRUE,scale="row",labRow="",labCol="",xlab="Samples",ylab="Genes",key = TRUE,dendrogram="both",density.info="none",trace="none")
		heatmap.2(dism,col=blueWhiteRedGradient(100),Rowv = TRUE,Colv = FALSE,scale="none",labRow="",labCol="",xlab="Samples",ylab="Genes",ColSideColors=groupCol,key = TRUE,dendrogram="none",density.info="none",trace="none",na.rm=T)
			
	dev.off()

}



getttest <- function(expression,tumor_id,normal_id){
		expressedGenes <- NULL
		temp <- sapply(1:nrow(expression),function(i){
					na.tumor <- sum(is.na(expression[i, tumor_id]))
					na.normal <- sum(is.na(expression[i, normal_id]))
					l.tumor <- length(tumor_id)
					l.normal <- length(normal_id)
					
			#print(i)
			if (na.tumor > 0.7*l.tumor | (l.tumor-na.tumor) <3 | na.normal > 0.7*l.normal | (l.normal - na.normal) < 3) {
			#print(i)
				expressedGenes <- rbind(expressedGenes, c(GeneName=as.character(rownames(expression)[i]),
							    p = "NA",
						  difference = "NA" ))

			} else {
				#print(i)
				tTest <- t.test(as.numeric(expression[i,tumor_id]), as.numeric(expression[i,normal_id]),na.rm=TRUE)
				disstance = tTest[["estimate"]]["mean of x"]-tTest[["estimate"]]["mean of y"]
				expressedGenes <- rbind(expressedGenes, c(GeneName=as.character(rownames(expression)[i]),
							    p = tTest[["p.value"]],
						  difference =disstance ))

			}
		return(expressedGenes)
		})
	return(temp)
}


read.data=function(fn, suffix.dup=F) {
	check=readLines(fn, n=1)
	check0=strsplit(check, '\t')[[1]][1]
	if (check0=='#1.2') {
		check=readLines(fn, n=3)[3]
		mat=read.delim(fn, as.is=T, skip=3, header=F)
		gnms=toupper(mat[,1])
		mat=mat[, -(1:2),drop=F]
		dnms=toupper(strsplit(check, '\t')[[1]][-(1:2)])
	} else {
		check2=readLines(fn, n=2)[2]
		check2=toupper(strsplit(check2, '\t')[[1]])
		nskip=1
		if (grepl('COMPOSITE *ELEMENT REF', check2[1])) nskip=2
		mat=read.delim(fn, as.is=T, skip=nskip, header=F)
		gnms=toupper(mat[,1])
		mat=mat[, -1,drop=F]
		dnms=toupper(strsplit(check, '\t')[[1]][-1])
	}
	ind=grep('^\\d+-SEP$', gnms)
	if (length(ind)>0) {
		tmp=gnms[ind]
		tmp=sub('-SEP','',tmp)
		tmp=sprintf('SEPT%s', tmp)
		gnms[ind]=tmp
	}
	
	ind=grep('^\\d+-MAR$', gnms)
	if (length(ind)>0) {
		tmp=gnms[ind]
		tmp=sub('-MAR','',tmp)
		tmp=sprintf('MARCH%s', tmp)
		gnms[ind]=tmp
	}
	
	ind=grep('^\\d+-APR$', gnms)
	if (length(ind)>0) {
		tmp=gnms[ind]
		tmp=sub('-APR','',tmp)
		tmp=sprintf('APR-%s', tmp)
		gnms[ind]=tmp
	}
	
	mat=as.matrix(mat)
	if (suffix.dup) {
		dup=rep(0, nrow(mat))
		gnm2=gnms
		ii=which(duplicated(gnm2))
		dup[ii]=dup[ii]+1
		while(length(ii)>0) {
			gnm2=paste(gnms, dup, sep='__')
			ii=which(duplicated(gnm2))
			dup[ii]=dup[ii]+1
		}
		gnm2=sub('\\__0$', '', gnm2)
		rownames(mat)=gnm2
	} else rownames(mat)=gnms
	colnames(mat)=dnms
	return(mat)
}

qvalue <-  function (p = NULL, lambda = seq(0, 0.9, 0.05), pi0.method = "smoother", 
    fdr.level = NULL, robust = FALSE, gui = FALSE, smooth.df = 3, 
    smooth.log.pi0 = FALSE) {
    if (is.null(p)) {
        qvalue.gui()
        return("Launching point-and-click...")
    }
    if (gui & !interactive()) 
        gui = FALSE
    if (min(p) < 0 || max(p) > 1) {
        if (gui) 
            eval(expression(postMsg(paste("ERROR: p-values not in valid range.", 
                "\n"))), parent.frame())
        else print("ERROR: p-values not in valid range.")
        return(0)
    }
    if (length(lambda) > 1 && length(lambda) < 4) {
        if (gui) 
            eval(expression(postMsg(paste("ERROR: If length of lambda greater than 1, you need at least 4 values.", 
                "\n"))), parent.frame())
        else print("ERROR: If length of lambda greater than 1, you need at least 4 values.")
        return(0)
    }
    if (length(lambda) > 1 && (min(lambda) < 0 || max(lambda) >= 
        1)) {
        if (gui) 
            eval(expression(postMsg(paste("ERROR: Lambda must be within [0, 1).", 
                "\n"))), parent.frame())
        else print("ERROR: Lambda must be within [0, 1).")
        return(0)
    }
    m <- length(p)
    if (length(lambda) == 1) {
        if (lambda < 0 || lambda >= 1) {
            if (gui) 
                eval(expression(postMsg(paste("ERROR: Lambda must be within [0, 1).", 
                  "\n"))), parent.frame())
            else print("ERROR: Lambda must be within [0, 1).")
            return(0)
        }
        pi0 <- mean(p >= lambda)/(1 - lambda)
        pi0 <- min(pi0, 1)
    }
    else {
        pi0 <- rep(0, length(lambda))
        for (i in 1:length(lambda)) {
            pi0[i] <- mean(p >= lambda[i])/(1 - lambda[i])
        }
        if (pi0.method == "smoother") {
            if (smooth.log.pi0) 
                pi0 <- log(pi0)
            spi0 <- smooth.spline(lambda, pi0, df = smooth.df)
            pi0 <- predict(spi0, x = max(lambda))$y
            if (smooth.log.pi0) 
                pi0 <- exp(pi0)
            pi0 <- min(pi0, 1)
        }
        else if (pi0.method == "bootstrap") {
            minpi0 <- min(pi0)
            mse <- rep(0, length(lambda))
            pi0.boot <- rep(0, length(lambda))
            for (i in 1:100) {
                p.boot <- sample(p, size = m, replace = TRUE)
                for (i in 1:length(lambda)) {
                  pi0.boot[i] <- mean(p.boot > lambda[i])/(1 - 
                    lambda[i])
                }
                mse <- mse + (pi0.boot - minpi0)^2
            }
            pi0 <- min(pi0[mse == min(mse)])
            pi0 <- min(pi0, 1)
        }
        else {
            print("ERROR: 'pi0.method' must be one of 'smoother' or 'bootstrap'.")
            return(0)
        }
    }
    if (pi0 <= 0) {
        if (gui) 
            eval(expression(postMsg(paste("ERROR: The estimated pi0 <= 0. Check that you have valid p-values or use another lambda method.", 
                "\n"))), parent.frame())
        else print("ERROR: The estimated pi0 <= 0. Check that you have valid p-values or use another lambda method.")
        return(0)
    }
    if (!is.null(fdr.level) && (fdr.level <= 0 || fdr.level > 
        1)) {
        if (gui) 
            eval(expression(postMsg(paste("ERROR: 'fdr.level' must be within (0, 1].", 
                "\n"))), parent.frame())
        else print("ERROR: 'fdr.level' must be within (0, 1].")
        return(0)
    }
    u <- order(p)
    qvalue.rank <- function(x) {
        idx <- sort.list(x)
        fc <- factor(x)
        nl <- length(levels(fc))
        bin <- as.integer(fc)
        tbl <- tabulate(bin)
        cs <- cumsum(tbl)
        tbl <- rep(cs, tbl)
        tbl[idx] <- tbl
        return(tbl)
    }
    v <- qvalue.rank(p)
    qvalue <- pi0 * m * p/v
    if (robust) {
        qvalue <- pi0 * m * p/(v * (1 - (1 - p)^m))
    }
    qvalue[u[m]] <- min(qvalue[u[m]], 1)
    for (i in (m - 1):1) {
        qvalue[u[i]] <- min(qvalue[u[i]], qvalue[u[i + 1]], 1)
    }
    if (!is.null(fdr.level)) {
        retval <- list(call = match.call(), pi0 = pi0, qvalues = qvalue, 
            pvalues = p, fdr.level = fdr.level, significant = (qvalue <= 
                fdr.level), lambda = lambda)
    }
    else {
        retval <- list(call = match.call(), pi0 = pi0, qvalues = qvalue, 
            pvalues = p, lambda = lambda)
    }
    class(retval) <- "qvalue"
    return(retval)
}

getColor <- function(subType, col = c("purple","darkgreen","red","blue","green","magenta1","black","yellow","orangered","brown"), 
          cNames = c("1", "2", "3", "4","5","6","7","8","9","10")){
    names(col) <- cNames
    
    return(col[subType])
}

loader <- function(){require(gplots, quietly = TRUE)}
